"""
ğŸ¤– Telegram Bot Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ Ğ½Ğ° Ğ¿ĞµÑ€ĞµÑ€Ñ‹Ğ²Ñ‹ - Ğ¡Ğ¢ĞĞ¢Ğ˜Ğ§ĞĞĞ• ĞœĞ•ĞĞ®
ğŸš€ 10-Ğ¼Ğ¸Ğ½ÑƒÑ‚Ğ½Ñ‹Ğµ ÑĞ»Ğ¾Ñ‚Ñ‹, Ğ»Ğ¸Ğ¼Ğ¸Ñ‚ 3 Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞºĞ°, Ğ½Ğ¸ĞºĞ½ĞµĞ¹Ğ¼Ñ‹ Ğ² Ñ€Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğ¸
"""
import os
import asyncio
import logging
import sqlite3
import threading
import time
import requests
import re
from datetime import datetime, timezone, timedelta
from typing import Optional, Dict, List

# FastAPI
from fastapi import FastAPI
import uvicorn

# Telegram
from telegram import Update, BotCommand
from telegram.ext import (
    Application, 
    CommandHandler, 
    ContextTypes,
    MessageHandler,
    filters
)

# ================== ĞšĞĞĞ¤Ğ˜Ğ“Ğ£Ğ ĞĞ¦Ğ˜Ğ¯ ==================
TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
if not TOKEN:
    raise ValueError("âŒ Ğ¢Ğ¾ĞºĞµĞ½ Ğ±Ğ¾Ñ‚Ğ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½! Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚Ğµ TELEGRAM_BOT_TOKEN")

PORT = int(os.getenv("PORT", 10000))
DATABASE_URL = os.getenv("DATABASE_URL", "breaks.db")

# ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ»Ğ¾Ğ³Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

# FastAPI Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ
app = FastAPI(
    title="Telegram Bot Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ Ğ½Ğ° Ğ¿ĞµÑ€ĞµÑ€Ñ‹Ğ²Ñ‹",
    description="Ğ‘Ğ¾Ñ‚ Ğ´Ğ»Ñ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ¿ĞµÑ€ĞµÑ€Ñ‹Ğ²Ğ¾Ğ² Ñ 10-Ğ¼Ğ¸Ğ½ÑƒÑ‚Ğ½Ñ‹Ğ¼Ğ¸ ÑĞ»Ğ¾Ñ‚Ğ°Ğ¼Ğ¸",
    version="6.0"
)

# Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ
bot_app: Optional[Application] = None
startup_time = datetime.now(timezone.utc)

# ================== Ğ‘ĞĞ—Ğ Ğ”ĞĞĞĞ«Ğ¥ ==================
def init_db():
    """Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"""
    conn = sqlite3.connect(DATABASE_URL)
    cursor = conn.cursor()
    
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            first_name TEXT,
            last_name TEXT,
            registration_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS breaks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            break_time TEXT,
            break_date DATE,
            registration_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (user_id)
        )
    ''')
    
    conn.commit()
    conn.close()
    logger.info("âœ… Ğ‘Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°")

# ================== Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜ Ğ”Ğ›Ğ¯ 10-ĞœĞ˜ĞĞ£Ğ¢ĞĞ«Ğ¥ Ğ¡Ğ›ĞĞ¢ĞĞ’ ==================
def get_break_slots() -> List[str]:
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ²ÑĞµÑ… Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ñ‚Ğ°Ğ¹Ğ¼ÑĞ»Ğ¾Ñ‚Ğ¾Ğ² (10-Ğ¼Ğ¸Ğ½ÑƒÑ‚Ğ½Ñ‹Ğµ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»Ñ‹ Ñ 10:00 Ğ´Ğ¾ 18:50)"""
    slots = []
    for hour in range(10, 19):
        for minute in [0, 10, 20, 30, 40, 50]:
            if hour == 18 and minute > 50:
                continue
            start = f"{hour:02d}:{minute:02d}"
            end_minute = minute + 10
            end_hour = hour
            if end_minute >= 60:
                end_hour = hour + 1
                end_minute = end_minute - 60
            end = f"{end_hour:02d}:{end_minute:02d}"
            slots.append(f"{start}-{end}")
    return slots

def get_nearby_slots() -> List[str]:
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑĞ»Ğ¾Ñ‚Ñ‹ Ğ½Ğ° Ğ±Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞ¸Ğµ 2 Ñ‡Ğ°ÑĞ° Ğ¾Ñ‚ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸ (10-Ğ¼Ğ¸Ğ½ÑƒÑ‚Ğ½Ñ‹Ğµ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»Ñ‹)"""
    moscow_tz = timezone(timedelta(hours=3))
    now = datetime.now(moscow_tz)
    current_hour = now.hour
    current_minute = now.minute
    
    # ĞĞºÑ€ÑƒĞ³Ğ»ÑĞµĞ¼ Ğ´Ğ¾ ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ³Ğ¾ 10-Ğ¼Ğ¸Ğ½ÑƒÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»Ğ°
    remainder = current_minute % 10
    if remainder == 0:
        start_minute = current_minute + 10
    else:
        start_minute = current_minute - remainder + 10
    
    start_hour = current_hour
    if start_minute >= 60:
        start_hour += 1
        start_minute -= 60
    
    nearby_slots = []
    all_slots = get_break_slots()
    
    # Ğ˜Ñ‰ĞµĞ¼ ÑĞ»Ğ¾Ñ‚Ñ‹ Ğ½Ğ° Ğ±Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞ¸Ğµ 2 Ñ‡Ğ°ÑĞ°
    target_time = start_hour * 60 + start_minute
    max_time = target_time + 120
    
    for slot in all_slots:
        slot_start = slot.split('-')[0]
        slot_hour = int(slot_start.split(':')[0])
        slot_minute = int(slot_start.split(':')[1])
        slot_time = slot_hour * 60 + slot_minute
        
        if target_time <= slot_time <= max_time:
            nearby_slots.append(slot)
            if len(nearby_slots) >= 8:
                break
    
    return nearby_slots

def get_slot_status(slot: str, break_date: str) -> str:
    """ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµÑ‚ ÑÑ‚Ğ°Ñ‚ÑƒÑ ÑĞ»Ğ¾Ñ‚Ğ°: ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ½Ğ¾, Ğ¼Ğ°Ğ»Ğ¾ Ğ¼ĞµÑÑ‚, Ğ·Ğ°Ğ½ÑÑ‚ (Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 3 Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞºĞ°)"""
    conn = sqlite3.connect(DATABASE_URL)
    cursor = conn.cursor()
    
    slot_start = slot.split('-')[0]
    
    cursor.execute('''
        SELECT COUNT(*) FROM breaks 
        WHERE break_time = ? AND break_date = ?
    ''', (slot_start, break_date))
    
    count = cursor.fetchone()[0]
    conn.close()
    
    if count >= 3:
        return "ğŸ”´ Ğ·Ğ°Ğ½ÑÑ‚"
    elif count >= 1:
        return "ğŸŸ¡ Ğ¼Ğ°Ğ»Ğ¾ Ğ¼ĞµÑÑ‚"
    else:
        return "ğŸŸ¢ ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ½Ğ¾"

# ================== Ğ’Ğ¡ĞŸĞĞœĞĞ“ĞĞ¢Ğ•Ğ›Ğ¬ĞĞ«Ğ• Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜ ==================
def get_moscow_time() -> str:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ Ğ²Ñ€ĞµĞ¼Ñ Ğ¿Ğ¾ ĞœĞ¾ÑĞºĞ²Ğµ"""
    moscow_tz = timezone(timedelta(hours=3))
    return datetime.now(moscow_tz).strftime("%H:%M")

def get_current_date() -> str:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ Ğ´Ğ°Ñ‚Ñƒ"""
    return datetime.now(timezone(timedelta(hours=3))).strftime("%Y-%m-%d")

def save_user_to_db(user_id: int, username: str, first_name: str, last_name: str):
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµÑ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ² Ğ±Ğ°Ğ·Ñƒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"""
    conn = sqlite3.connect(DATABASE_URL)
    cursor = conn.cursor()
    
    cursor.execute('''
        INSERT OR IGNORE INTO users (user_id, username, first_name, last_name)
        VALUES (?, ?, ?, ?)
    ''', (user_id, username, first_name, last_name))
    
    conn.commit()
    conn.close()

def save_break_to_db(user_id: int, break_time: str, break_date: str) -> bool:
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµÑ‚ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ½Ğ° Ğ¿ĞµÑ€ĞµÑ€Ñ‹Ğ² Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¾Ğ¹ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ° Ğ² 3 Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞºĞ°"""
    conn = sqlite3.connect(DATABASE_URL)
    cursor = conn.cursor()
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ½Ğµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ½ Ğ»Ğ¸ ÑƒĞ¶Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ
    cursor.execute('''
        SELECT COUNT(*) FROM breaks 
        WHERE user_id = ? AND break_date = ? AND break_time = ?
    ''', (user_id, break_date, break_time))
    
    count = cursor.fetchone()[0]
    
    if count > 0:
        conn.close()
        return False
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹ Ğ½Ğ° ÑÑ‚Ğ¾Ñ‚ ÑĞ»Ğ¾Ñ‚ (Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 3)
    cursor.execute('''
        SELECT COUNT(*) FROM breaks 
        WHERE break_time = ? AND break_date = ?
    ''', (break_time, break_date))
    
    slot_count = cursor.fetchone()[0]
    
    if slot_count >= 3:
        conn.close()
        return False
    
    cursor.execute('''
        INSERT INTO breaks (user_id, break_time, break_date)
        VALUES (?, ?, ?)
    ''', (user_id, break_time, break_date))
    
    conn.commit()
    conn.close()
    return True

def get_user_breaks(user_id: int, break_date: str) -> List[str]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ğ¿ĞµÑ€ĞµÑ€Ñ‹Ğ²Ñ‹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
    conn = sqlite3.connect(DATABASE_URL)
    cursor = conn.cursor()
    
    cursor.execute('''
        SELECT break_time FROM breaks 
        WHERE user_id = ? AND break_date = ?
        ORDER BY break_time
    ''', (user_id, break_date))
    
    breaks = [row[0] for row in cursor.fetchall()]
    conn.close()
    return breaks

def get_all_breaks(break_date: str) -> Dict[str, List[str]]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ğ²ÑĞµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ Ğ½Ğ° Ğ¿ĞµÑ€ĞµÑ€Ñ‹Ğ²Ñ‹ Ñ Ğ½Ğ¸ĞºĞ½ĞµĞ¹Ğ¼Ğ°Ğ¼Ğ¸ (first_name)"""
    conn = sqlite3.connect(DATABASE_URL)
    cursor = conn.cursor()
    
    cursor.execute('''
        SELECT u.first_name, b.break_time 
        FROM breaks b
        JOIN users u ON b.user_id = u.user_id
        WHERE b.break_date = ?
        ORDER BY b.break_time
    ''', (break_date,))
    
    breaks = {}
    for first_name, break_time in cursor.fetchall():
        if break_time not in breaks:
            breaks[break_time] = []
        name = first_name if first_name else "ĞĞ½Ğ¾Ğ½Ğ¸Ğ¼"
        breaks[break_time].append(name)
    
    conn.close()
    return breaks

def get_statistics() -> Dict:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºÑƒ Ğ¿Ğ¾ Ğ·Ğ°Ğ¿Ğ¸ÑÑĞ¼"""
    conn = sqlite3.connect(DATABASE_URL)
    cursor = conn.cursor()
    
    cursor.execute("SELECT COUNT(*) FROM users")
    total_users = cursor.fetchone()[0]
    
    cursor.execute("SELECT COUNT(*) FROM breaks")
    total_breaks = cursor.fetchone()[0]
    
    current_date = get_current_date()
    cursor.execute("SELECT COUNT(*) FROM breaks WHERE break_date = ?", (current_date,))
    today_breaks = cursor.fetchone()[0]
    
    cursor.execute('''
        SELECT break_time, COUNT(*) as count 
        FROM breaks 
        GROUP BY break_time 
        ORDER BY count DESC 
        LIMIT 3
    ''')
    popular_times = cursor.fetchall()
    
    cursor.execute('''
        SELECT COUNT(DISTINCT user_id) 
        FROM breaks 
        WHERE break_date = ?
    ''', (current_date,))
    active_users = cursor.fetchone()[0]
    
    conn.close()
    
    return {
        "total_users": total_users,
        "total_breaks": total_breaks,
        "today_breaks": today_breaks,
        "popular_times": popular_times,
        "active_users": active_users
    }

# ================== ĞšĞĞœĞĞĞ”Ğ« Ğ‘ĞĞ¢Ğ ==================
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ /start"""
    user = update.effective_user
    
    logger.info(f"ğŸš€ /start Ğ¾Ñ‚ {user.id}")
    
    save_user_to_db(
        user_id=user.id,
        username=user.username,
        first_name=user.first_name,
        last_name=user.last_name
    )
    
    welcome_text = (
        f"ğŸ‘‹ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚, {user.first_name}!\n\n"
        f"ğŸ¤– Ğ‘Ğ¾Ñ‚ Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ Ğ½Ğ° Ğ¿ĞµÑ€ĞµÑ€Ñ‹Ğ²Ñ‹\n"
        f"ğŸ“… Ğ¡ĞµĞ³Ğ¾Ğ´Ğ½Ñ: {get_current_date()}\n"
        f"â° Ğ’Ñ€ĞµĞ¼Ñ: {get_moscow_time()}\n\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"ğŸ“Œ Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ¼ĞµĞ½Ñ Ğ²Ğ½Ğ¸Ğ·Ñƒ ÑĞºÑ€Ğ°Ğ½Ğ°:\n\n"
        f"ğŸ“ /breaks - Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ½Ğ° Ğ¿ĞµÑ€ĞµÑ€Ñ‹Ğ²\n"
        f"ğŸ“‹ /mybreaks - ĞœĞ¾Ğ¸ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸\n"
        f"ğŸ‘¥ /allbreaks - Ğ Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ\n"
        f"ğŸ“Š /stats - Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°\n"
        f"â“ /help - ĞŸĞ¾Ğ¼Ğ¾Ñ‰ÑŒ\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    )
    
    await update.message.reply_text(welcome_text)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ /help"""
    help_text = (
        f"ğŸ¤– ĞŸĞĞœĞĞ©Ğ¬ ĞŸĞ Ğ‘ĞĞ¢Ğ£\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"ğŸ“Œ Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹:\n\n"
        f"ğŸ  /start - Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ\n"
        f"ğŸ“ /breaks - Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ½Ğ° Ğ¿ĞµÑ€ĞµÑ€Ñ‹Ğ²\n"
        f"ğŸ“‹ /mybreaks - ĞœĞ¾Ğ¸ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸\n"
        f"ğŸ‘¥ /allbreaks - Ğ Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ\n"
        f"ğŸ“Š /stats - Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ±Ğ¾Ñ‚Ğ°\n"
        f"â“ /help - Ğ­Ñ‚Ğ° ÑĞ¿Ñ€Ğ°Ğ²ĞºĞ°\n\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"â° Ğ¢Ğ°Ğ¹Ğ¼ÑĞ»Ğ¾Ñ‚Ñ‹: 10 Ğ¼Ğ¸Ğ½ÑƒÑ‚\n"
        f"ğŸ‘¥ Ğ›Ğ¸Ğ¼Ğ¸Ñ‚: 3 Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞºĞ° Ğ½Ğ° ÑĞ»Ğ¾Ñ‚\n\n"
        f"âœ… ĞšĞ°Ğº Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ:\n"
        f"1. ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ /breaks\n"
        f"2. Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑĞ»Ğ¾Ñ‚ Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ°\n"
        f"3. ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ Ğ²Ñ€ĞµĞ¼Ñ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° (Ğ§Ğ§:ĞœĞœ)\n\n"
        f"ğŸ“Œ ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: 14:30"
    )
    
    await update.message.reply_text(help_text)

async def breaks_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ Ğ½Ğ° Ğ¿ĞµÑ€ĞµÑ€Ñ‹Ğ² Ñ 10-Ğ¼Ğ¸Ğ½ÑƒÑ‚Ğ½Ñ‹Ğ¼Ğ¸ ÑĞ»Ğ¾Ñ‚Ğ°Ğ¼Ğ¸"""
    user_id = update.effective_user.id
    current_date = get_current_date()
    moscow_time = get_moscow_time()
    user_breaks = get_user_breaks(user_id, current_date)
    
    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑĞ»Ğ¾Ñ‚Ñ‹ Ğ½Ğ° Ğ±Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞ¸Ğµ 2 Ñ‡Ğ°ÑĞ°
    nearby_slots = get_nearby_slots()
    
    text = (
        f"ğŸ¯ Ğ’Ğ«Ğ‘ĞĞ  Ğ’Ğ Ğ•ĞœĞ•ĞĞ˜ Ğ”Ğ›Ğ¯ ĞŸĞ•Ğ Ğ•Ğ Ğ«Ğ’Ğ\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"ğŸ• Ğ¢ĞµĞºÑƒÑ‰ĞµĞµ Ğ²Ñ€ĞµĞ¼Ñ (ĞœĞ¾ÑĞºĞ²Ğ°): {moscow_time}\n"
        f"ğŸ“… Ğ”Ğ°Ñ‚Ğ°: {current_date}\n"
        f"â³ Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ ÑĞ»Ğ¾Ñ‚Ñ‹ Ğ½Ğ° Ğ±Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞ¸Ğµ 2 Ñ‡Ğ°ÑĞ°\n\n"
        f"ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ ÑĞ»Ğ¾Ñ‚Ğ¾Ğ²:\n"
        f"ğŸŸ¢ - ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ½Ğ¾\n"
        f"ğŸŸ¡ - Ğ¼Ğ°Ğ»Ğ¾ Ğ¼ĞµÑÑ‚ (1-2 Ñ‡ĞµĞ».)\n"
        f"ğŸ”´ - Ğ·Ğ°Ğ½ÑÑ‚ (3 Ñ‡ĞµĞ».)\n\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"ğŸ—“ï¸ Ğ’Ğ«Ğ‘Ğ•Ğ Ğ˜Ğ¢Ğ• Ğ£Ğ”ĞĞ‘ĞĞĞ• Ğ’Ğ Ğ•ĞœĞ¯:\n\n"
    )
    
    # Ğ Ğ°Ğ·Ğ±Ğ¸Ğ²Ğ°ĞµĞ¼ ÑĞ»Ğ¾Ñ‚Ñ‹ Ğ½Ğ° 2 ĞºĞ¾Ğ»Ğ¾Ğ½ĞºĞ¸
    for i in range(0, len(nearby_slots), 2):
        if i + 1 < len(nearby_slots):
            slot1 = nearby_slots[i]
            slot2 = nearby_slots[i + 1]
            
            status1 = get_slot_status(slot1, current_date)
            status2 = get_slot_status(slot2, current_date)
            
            slot1_start = slot1.split('-')[0]
            slot2_start = slot2.split('-')[0]
            
            if slot1_start in user_breaks:
                slot1_display = f"âœ… {slot1} (Ğ²Ñ‹)"
            else:
                slot1_display = f"{status1} {slot1}"
                
            if slot2_start in user_breaks:
                slot2_display = f"âœ… {slot2} (Ğ²Ñ‹)"
            else:
                slot2_display = f"{status2} {slot2}"
            
            text += f"{slot1_display:<35} {slot2_display:<35}\n"
        else:
            slot1 = nearby_slots[i]
            status1 = get_slot_status(slot1, current_date)
            slot1_start = slot1.split('-')[0]
            
            if slot1_start in user_breaks:
                slot1_display = f"âœ… {slot1} (Ğ²Ñ‹)"
            else:
                slot1_display = f"{status1} {slot1}"
            
            text += f"{slot1_display:<35}\n"
        
        text += "\n"
    
    text += (
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"âœï¸ Ğ§Ñ‚Ğ¾Ğ±Ñ‹ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ, Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ Ğ²Ñ€ĞµĞ¼Ñ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° ÑĞ»Ğ¾Ñ‚Ğ°\n"
        f"   Ğ² Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ Ğ§Ğ§:ĞœĞœ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 14:30)\n\n"
        f"ğŸ”„ /breaks - ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ÑĞ»Ğ¾Ñ‚Ñ‹\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    )
    
    await update.message.reply_text(text)

async def process_break_registration(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ñ… ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ñ Ğ²Ñ€ĞµĞ¼ĞµĞ½ĞµĞ¼"""
    user_id = update.effective_user.id
    message_text = update.message.text.strip()
    current_date = get_current_date()
    
    time_pattern = r'^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$'
    
    if re.match(time_pattern, message_text):
        if len(message_text) == 4:
            message_text = f"0{message_text}"
        
        valid_times = [slot.split('-')[0] for slot in get_break_slots()]
        
        if message_text in valid_times:
            success = save_break_to_db(user_id, message_text, current_date)
            
            if success:
                full_slot = None
                for slot in get_break_slots():
                    if slot.startswith(message_text):
                        full_slot = slot
                        break
                
                conn = sqlite3.connect(DATABASE_URL)
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT COUNT(*) FROM breaks 
                    WHERE break_time = ? AND break_date = ?
                ''', (message_text, current_date))
                current_count = cursor.fetchone()[0]
                conn.close()
                
                response = (
                    f"âœ… Ğ—ĞĞŸĞ˜Ğ¡Ğ¬ ĞŸĞĞ”Ğ¢Ğ’Ğ•Ğ Ğ–Ğ”Ğ•ĞĞ!\n"
                    f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
                    f"ğŸ• Ğ¡Ğ»Ğ¾Ñ‚: {full_slot or message_text}\n"
                    f"ğŸ“… Ğ”Ğ°Ñ‚Ğ°: {current_date}\n"
                    f"ğŸ‘¥ ĞœĞµÑÑ‚ Ğ·Ğ°Ğ½ÑÑ‚Ğ¾: {current_count}/3\n\n"
                    f"Ğ’Ñ‹ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ñ‹ Ğ½Ğ° Ğ¿ĞµÑ€ĞµÑ€Ñ‹Ğ²!\n\n"
                    f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                    f"ğŸ“‹ /mybreaks - ĞœĞ¾Ğ¸ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸\n"
                    f"ğŸ‘¥ /allbreaks - Ğ Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ\n"
                    f"ğŸ”„ /breaks - ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ÑĞ»Ğ¾Ñ‚Ñ‹"
                )
                logger.info(f"âœ… Ğ—Ğ°Ğ¿Ğ¸ÑÑŒ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ°: user={user_id}, time={message_text}, count={current_count}/3")
            else:
                conn = sqlite3.connect(DATABASE_URL)
                cursor = conn.cursor()
                
                cursor.execute('''
                    SELECT COUNT(*) FROM breaks 
                    WHERE user_id = ? AND break_date = ? AND break_time = ?
                ''', (user_id, current_date, message_text))
                already_registered = cursor.fetchone()[0] > 0
                
                cursor.execute('''
                    SELECT COUNT(*) FROM breaks 
                    WHERE break_time = ? AND break_date = ?
                ''', (message_text, current_date))
                slot_full = cursor.fetchone()[0] >= 3
                
                conn.close()
                
                if already_registered:
                    response = (
                        f"âš ï¸ Ğ—ĞĞŸĞ˜Ğ¡Ğ¬ ĞĞ• Ğ¡ĞĞ—Ğ”ĞĞĞ\n"
                        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
                        f"âŒ Ğ’Ñ‹ ÑƒĞ¶Ğµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ñ‹ Ğ½Ğ° ÑÑ‚Ğ¾Ñ‚ ÑĞ»Ğ¾Ñ‚!\n\n"
                        f"ğŸ“‹ /mybreaks - ĞœĞ¾Ğ¸ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸\n"
                        f"ğŸ”„ /breaks - Ğ’Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ´Ñ€ÑƒĞ³Ğ¾Ğµ Ğ²Ñ€ĞµĞ¼Ñ"
                    )
                elif slot_full:
                    response = (
                        f"âš ï¸ Ğ—ĞĞŸĞ˜Ğ¡Ğ¬ ĞĞ• Ğ¡ĞĞ—Ğ”ĞĞĞ\n"
                        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
                        f"âŒ Ğ­Ñ‚Ğ¾Ñ‚ ÑĞ»Ğ¾Ñ‚ ÑƒĞ¶Ğµ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ğ·Ğ°Ğ½ÑÑ‚ (3/3)!\n\n"
                        f"ğŸ”„ /breaks - Ğ’Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ´Ñ€ÑƒĞ³Ğ¾Ğµ Ğ²Ñ€ĞµĞ¼Ñ"
                    )
                else:
                    response = (
                        f"âš ï¸ Ğ—ĞĞŸĞ˜Ğ¡Ğ¬ ĞĞ• Ğ¡ĞĞ—Ğ”ĞĞĞ\n"
                        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
                        f"âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ\n\n"
                        f"ğŸ”„ /breaks - ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑĞ½Ğ¾Ğ²Ğ°"
                    )
                
                logger.info(f"âš ï¸ Ğ—Ğ°Ğ¿Ğ¸ÑÑŒ Ğ½Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ°: user={user_id}, time={message_text}")
            
            await update.message.reply_text(response)

async def mybreaks_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
    user_id = update.effective_user.id
    current_date = get_current_date()
    
    user_breaks = get_user_breaks(user_id, current_date)
    
    if user_breaks:
        text = (
            f"ğŸ“‹ ĞœĞĞ˜ Ğ—ĞĞŸĞ˜Ğ¡Ğ˜\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"ğŸ“… Ğ”Ğ°Ñ‚Ğ°: {current_date}\n\n"
        )
        for i, break_time in enumerate(user_breaks, 1):
            full_slot = break_time
            for slot in get_break_slots():
                if slot.startswith(break_time):
                    full_slot = slot
                    break
            text += f"{i}. ğŸ• {full_slot}\n"
    else:
        text = (
            f"ğŸ“‹ ĞœĞĞ˜ Ğ—ĞĞŸĞ˜Ğ¡Ğ˜\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
            f"âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹ Ğ½Ğ° ÑĞµĞ³Ğ¾Ğ´Ğ½Ñ\n\n"
            f"ğŸ“ /breaks - Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ½Ğ° Ğ¿ĞµÑ€ĞµÑ€Ñ‹Ğ²"
        )
    
    await update.message.reply_text(text)

async def allbreaks_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Ñ€Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ ÑĞ¾ Ğ²ÑĞµĞ¼Ğ¸ 10-Ğ¼Ğ¸Ğ½ÑƒÑ‚Ğ½Ñ‹Ğ¼Ğ¸ ÑĞ»Ğ¾Ñ‚Ğ°Ğ¼Ğ¸ Ğ¸ Ğ½Ğ¸ĞºĞ½ĞµĞ¹Ğ¼Ğ°Ğ¼Ğ¸"""
    current_date = get_current_date()
    all_breaks = get_all_breaks(current_date)
    
    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ’Ğ¡Ğ• Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğµ 10-Ğ¼Ğ¸Ğ½ÑƒÑ‚Ğ½Ñ‹Ğµ ÑĞ»Ğ¾Ñ‚Ñ‹
    all_slots = get_break_slots()
    
    text = (
        f"ğŸ‘¥ Ğ ĞĞ¡ĞŸĞ˜Ğ¡ĞĞĞ˜Ğ• ({current_date}):\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    )
    
    # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ ÑĞ»Ğ¾Ñ‚Ñ‹ Ñ 10:00 Ğ´Ğ¾ 18:50
    for slot in all_slots:
        break_time = slot.split('-')[0]
        
        if break_time in all_breaks:
            names = ", ".join(all_breaks[break_time])
            text += f"{slot}: {names}\n"
        else:
            text += f"{slot}: ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ½Ğ¾\n"
    
    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºÑƒ
    total_slots = len(all_slots)
    booked_slots = len(all_breaks)
    free_slots = total_slots - booked_slots
    
    text += f"\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
    text += f"ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°:\n"
    text += f"ğŸŸ¢ Ğ¡Ğ²Ğ¾Ğ±Ğ¾Ğ´Ğ½Ğ¾: {free_slots} ÑĞ»Ğ¾Ñ‚Ğ¾Ğ²\n"
    text += f"ğŸ“ Ğ—Ğ°Ğ½ÑÑ‚Ğ¾: {booked_slots} ÑĞ»Ğ¾Ñ‚Ğ¾Ğ²\n"
    text += f"â° Ğ’ÑĞµĞ³Ğ¾: {total_slots} ÑĞ»Ğ¾Ñ‚Ğ¾Ğ²\n"
    
    await update.message.reply_text(text)

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºÑƒ"""
    stats = get_statistics()
    
    text = (
        f"ğŸ“Š Ğ¡Ğ¢ĞĞ¢Ğ˜Ğ¡Ğ¢Ğ˜ĞšĞ Ğ‘ĞĞ¢Ğ\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"ğŸ‘¥ Ğ’ÑĞµĞ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹: {stats['total_users']}\n"
        f"ğŸ“ Ğ’ÑĞµĞ³Ğ¾ Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹: {stats['total_breaks']}\n"
        f"ğŸ“… Ğ—Ğ°Ğ¿Ğ¸ÑĞµĞ¹ ÑĞµĞ³Ğ¾Ğ´Ğ½Ñ: {stats['today_breaks']}\n"
        f"ğŸ• ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞµĞ³Ğ¾Ğ´Ğ½Ñ: {stats['active_users']}\n\n"
    )
    
    if stats['popular_times']:
        text += "ğŸ”¥ ĞŸĞ¾Ğ¿ÑƒĞ»ÑÑ€Ğ½Ğ¾Ğµ Ğ²Ñ€ĞµĞ¼Ñ:\n"
        for i, (time, count) in enumerate(stats['popular_times'], 1):
            full_slot = time
            for slot in get_break_slots():
                if slot.startswith(time):
                    full_slot = slot
                    break
            text += f"{i}. {full_slot} â€” {count} Ğ·Ğ°Ğ¿.\n"
    
    await update.message.reply_text(text)

async def debug_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ /debug - Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹"""
    user = update.effective_user
    
    logger.info(f"ğŸ” /debug Ğ¾Ñ‚ {user.id}")
    
    db_status = "âœ… Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚"
    try:
        conn = sqlite3.connect(DATABASE_URL)
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM users")
        user_count = cursor.fetchone()[0]
        cursor.execute("SELECT COUNT(*) FROM breaks")
        break_count = cursor.fetchone()[0]
        conn.close()
        db_info = f"ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹: {user_count}, Ğ—Ğ°Ğ¿Ğ¸ÑĞµĞ¹: {break_count}"
    except Exception as e:
        db_status = f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°"
        db_info = str(e)[:100]
    
    response = (
        f"ğŸ”§ Ğ”Ğ˜ĞĞ“ĞĞĞ¡Ğ¢Ğ˜ĞšĞ\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"ğŸ¤– Ğ‘Ğ¾Ñ‚: âœ… Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚\n"
        f"ğŸ‘¤ Ğ’Ğ°Ñˆ ID: {user.id}\n"
        f"ğŸ• ĞœĞ¾ÑĞºĞ²Ğ°: {get_moscow_time()}\n"
        f"ğŸ“… Ğ”Ğ°Ñ‚Ğ°: {get_current_date()}\n"
        f"ğŸ—„ï¸ Ğ‘Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…: {db_status}\n"
        f"   {db_info}\n\n"
        f"â° Ğ¢Ğ°Ğ¹Ğ¼ÑĞ»Ğ¾Ñ‚Ñ‹: 10 Ğ¼Ğ¸Ğ½ÑƒÑ‚\n"
        f"ğŸ‘¥ Ğ›Ğ¸Ğ¼Ğ¸Ñ‚: 3 Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞºĞ°\n"
        f"ğŸ”„ ĞĞ²Ñ‚Ğ¾-Ğ¿Ğ¸Ğ½Ğ³: ĞºĞ°Ğ¶Ğ´Ñ‹Ğµ 8 Ğ¼Ğ¸Ğ½ÑƒÑ‚\n"
        f"ğŸ“± ĞœĞµĞ½Ñ: Ğ¡Ñ‚Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    )
    
    await update.message.reply_text(response)

# ================== Ğ—ĞĞŸĞ£Ğ¡Ğš Ğ¢Ğ•Ğ›Ğ•Ğ“Ğ ĞĞœ Ğ‘ĞĞ¢Ğ ==================
async def setup_bot_commands(application: Application):
    """Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´ Ğ´Ğ»Ñ Ğ¼ĞµĞ½Ñ Telegram"""
    commands = [
        BotCommand("start", "ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ"),
        BotCommand("breaks", "ğŸ“ Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ½Ğ° Ğ¿ĞµÑ€ĞµÑ€Ñ‹Ğ²"),
        BotCommand("mybreaks", "ğŸ“‹ ĞœĞ¾Ğ¸ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸"),
        BotCommand("allbreaks", "ğŸ‘¥ Ğ Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ"),
        BotCommand("stats", "ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°"),
        BotCommand("help", "â“ ĞŸĞ¾Ğ¼Ğ¾Ñ‰ÑŒ"),
        BotCommand("debug", "ğŸ”§ Ğ”Ğ¸Ğ°Ğ³Ğ½Ğ¾ÑÑ‚Ğ¸ĞºĞ°"),
    ]
    await application.bot.set_my_commands(commands)
    logger.info("âœ… ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ Ğ¼ĞµĞ½Ñ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ñ‹")

async def start_bot():
    """Ğ—Ğ°Ğ¿ÑƒÑĞº Telegram Ğ±Ğ¾Ñ‚Ğ°"""
    global bot_app
    
    logger.info("ğŸ¤– Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Telegram Ğ±Ğ¾Ñ‚Ğ°...")
    
    await asyncio.sleep(5)
    
    try:
        bot_app = Application.builder().token(TOKEN).build()
        logger.info("âœ… ĞŸÑ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¾")
        
        await setup_bot_commands(bot_app)
        
        bot_app.add_handler(CommandHandler("start", start_command))
        bot_app.add_handler(CommandHandler("help", help_command))
        bot_app.add_handler(CommandHandler("debug", debug_command))
        bot_app.add_handler(CommandHandler("breaks", breaks_command))
        bot_app.add_handler(CommandHandler("mybreaks", mybreaks_command))
        bot_app.add_handler(CommandHandler("allbreaks", allbreaks_command))
        bot_app.add_handler(CommandHandler("stats", stats_command))
        
        bot_app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, process_break_registration))
        
        logger.info("âœ… Ğ’ÑĞµ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ¸ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ñ‹")
        
        await bot_app.initialize()
        await bot_app.start()
        
        await bot_app.updater.start_polling(
            poll_interval=1.0,
            timeout=20,
            drop_pending_updates=True
        )
        
        logger.info("âœ… Telegram Ğ±Ğ¾Ñ‚ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½!")
        return True
        
    except Exception as e:
        logger.error(f"ğŸ’¥ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ¿ÑƒÑĞºĞµ Ğ±Ğ¾Ñ‚Ğ°: {e}")
        return False

# ================== ĞĞ’Ğ¢Ğ-ĞŸĞ˜ĞĞ“ ==================
def start_auto_ping():
    """Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµÑ‚ Ğ°Ğ²Ñ‚Ğ¾-Ğ¿Ğ¸Ğ½Ğ³ Ğ² Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞµ"""
    def ping_worker():
        time.sleep(30)
        url = "https://ded1-8.onrender.com"
        logger.info(f"ğŸ§µ ĞĞ²Ñ‚Ğ¾-Ğ¿Ğ¸Ğ½Ğ³ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½ Ğ´Ğ»Ñ {url}")
        
        ping_count = 0
        while True:
            ping_count += 1
            try:
                response = requests.get(f"{url}/health", timeout=10)
                if response.status_code == 200:
                    logger.info(f"âœ… ĞĞ²Ñ‚Ğ¾-Ğ¿Ğ¸Ğ½Ğ³ #{ping_count} ÑƒÑĞ¿ĞµÑˆĞµĞ½")
                else:
                    logger.warning(f"âš ï¸ ĞĞ²Ñ‚Ğ¾-Ğ¿Ğ¸Ğ½Ğ³ #{ping_count}: ĞºĞ¾Ğ´ {response.status_code}")
            except Exception as e:
                logger.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ°Ğ²Ñ‚Ğ¾-Ğ¿Ğ¸Ğ½Ğ³Ğ° #{ping_count}: {e}")
            
            time.sleep(480)
    
    thread = threading.Thread(target=ping_worker, daemon=True)
    thread.start()
    logger.info("âœ… ĞŸĞ¾Ñ‚Ğ¾Ğº Ğ°Ğ²Ñ‚Ğ¾-Ğ¿Ğ¸Ğ½Ğ³Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½")
    return thread

# ================== FASTAPI Ğ­ĞĞ”ĞŸĞĞ˜ĞĞ¢Ğ« ==================
@app.get("/")
async def root():
    """ĞšĞ¾Ñ€Ğ½ĞµĞ²Ğ¾Ğ¹ ÑĞ½Ğ´Ğ¿Ğ¾Ğ¸Ğ½Ñ‚"""
    return {
        "message": "Telegram Bot Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ Ğ½Ğ° Ğ¿ĞµÑ€ĞµÑ€Ñ‹Ğ²Ñ‹",
        "status": "running",
        "bot": "active" if bot_app else "starting",
        "time_moscow": get_moscow_time(),
        "date": get_current_date(),
        "uptime": str(datetime.now(timezone.utc) - startup_time),
        "version": "6.0",
        "slot_duration": "10 Ğ¼Ğ¸Ğ½ÑƒÑ‚",
        "slot_limit": "3 Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞºĞ°"
    }

@app.get("/health")
async def health_check():
    """Health check Ğ´Ğ»Ñ Render"""
    return {
        "status": "healthy",
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "bot_running": bool(bot_app),
        "time_moscow": get_moscow_time()
    }

@app.get("/status")
async def status():
    """Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹"""
    return {
        "server": {
            "uptime": str(datetime.now(timezone.utc) - startup_time),
            "port": PORT,
            "startup_time": startup_time.isoformat()
        },
        "bot": {
            "initialized": bool(bot_app),
            "database": "connected",
            "menu_type": "static_commands",
            "slot_duration": "10 Ğ¼Ğ¸Ğ½ÑƒÑ‚",
            "slot_limit": "3 Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞºĞ°"
        }
    }

@app.get("/ping")
async def ping():
    """Ğ ÑƒÑ‡Ğ½Ğ¾Ğ¹ Ğ¿Ğ¸Ğ½Ğ³"""
    return {"ping": "pong", "time": get_moscow_time()}

# ================== Ğ—ĞĞŸĞ£Ğ¡Ğš ĞŸĞ Ğ˜Ğ›ĞĞ–Ğ•ĞĞ˜Ğ¯ ==================
@app.on_event("startup")
async def startup_event():
    """Ğ—Ğ°Ğ¿ÑƒÑĞº Ğ¿Ñ€Ğ¸ ÑÑ‚Ğ°Ñ€Ñ‚Ğµ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""
    logger.info("=" * 60)
    logger.info("ğŸš€ Ğ—ĞĞŸĞ£Ğ¡Ğš Ğ‘ĞĞ¢Ğ Ğ”Ğ›Ğ¯ Ğ—ĞĞŸĞ˜Ğ¡Ğ˜ ĞĞ ĞŸĞ•Ğ Ğ•Ğ Ğ«Ğ’Ğ«")
    logger.info("=" * 60)
    
    init_db()
    
    logger.info(f"âœ… Ğ¢Ğ¾ĞºĞµĞ½ Ğ±Ğ¾Ñ‚Ğ°: ĞĞ°Ğ¹Ğ´ĞµĞ½")
    logger.info(f"â° Ğ’Ñ€ĞµĞ¼Ñ Ğ¿Ğ¾ ĞœĞ¾ÑĞºĞ²Ğµ: {get_moscow_time()}")
    logger.info(f"ğŸ“… Ğ”Ğ°Ñ‚Ğ°: {get_current_date()}")
    logger.info(f"ğŸŒ ĞŸĞ¾Ñ€Ñ‚: {PORT}")
    logger.info(f"â±ï¸ Ğ¢Ğ°Ğ¹Ğ¼ÑĞ»Ğ¾Ñ‚Ñ‹: 10 Ğ¼Ğ¸Ğ½ÑƒÑ‚")
    logger.info(f"ğŸ‘¥ Ğ›Ğ¸Ğ¼Ğ¸Ñ‚: 3 Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞºĞ° Ğ½Ğ° ÑĞ»Ğ¾Ñ‚")
    logger.info("=" * 60)
    
    start_auto_ping()
    logger.info("ğŸ”§ ĞĞ²Ñ‚Ğ¾-Ğ¿Ğ¸Ğ½Ğ³ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½ (Ğ¿Ğ¸Ğ½Ğ³ ĞºĞ°Ğ¶Ğ´Ñ‹Ğµ 8 Ğ¼Ğ¸Ğ½ÑƒÑ‚)")
    
    success = await start_bot()
    
    if success:
        logger.info("ğŸ‰ Ğ’ÑĞµ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½Ñ‹ Ğ¸ Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ñ‹ Ğº Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğµ!")
        logger.info("ğŸ“± Ğ ĞµĞ¶Ğ¸Ğ¼: Ğ¡Ğ¢ĞĞ¢Ğ˜Ğ§ĞĞĞ• ĞœĞ•ĞĞ® | 10-ĞœĞ˜ĞĞ£Ğ¢ĞĞ«Ğ• Ğ¡Ğ›ĞĞ¢Ğ« | Ğ›Ğ˜ĞœĞ˜Ğ¢ 3 Ğ§Ğ•Ğ›ĞĞ’Ğ•ĞšĞ")
    else:
        logger.error("ğŸ’¥ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ·Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ğ±Ğ¾Ñ‚Ğ°!")

@app.on_event("shutdown")
async def shutdown_event():
    """ĞÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğ¸"""
    logger.info("ğŸ›‘ Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹...")
    
    if bot_app:
        try:
            await bot_app.updater.stop()
            await bot_app.stop()
            await bot_app.shutdown()
            logger.info("âœ… Telegram Ğ±Ğ¾Ñ‚ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½")
        except Exception as e:
            logger.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞµ Ğ±Ğ¾Ñ‚Ğ°: {e}")
    
    logger.info("ğŸ‘‹ Ğ¡ĞµÑ€Ğ²ĞµÑ€ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½")

# ================== Ğ¢ĞĞ§ĞšĞ Ğ’Ğ¥ĞĞ”Ğ ==================
def main():
    """ĞÑĞ½Ğ¾Ğ²Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ°"""
    logger.info(f"ğŸŒ Ğ—Ğ°Ğ¿ÑƒÑĞº ÑĞµÑ€Ğ²ĞµÑ€Ğ° Ğ½Ğ° Ğ¿Ğ¾Ñ€Ñ‚Ñƒ {PORT}...")
    
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=PORT,
        access_log=False,
        log_level="info"
    )

if __name__ == "__main__":
    main()
