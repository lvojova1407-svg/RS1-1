"""
ü§ñ Telegram Bot –¥–ª—è –∑–∞–ø–∏—Å–∏ –Ω–∞ –ø–µ—Ä–µ—Ä—ã–≤—ã - INLINE –ö–ù–û–ü–ö–ò (–° –û–¢–ú–ï–ù–û–ô –ó–ê–ü–ò–°–ò)
üöÄ 10-–º–∏–Ω—É—Ç–Ω—ã–µ —Å–ª–æ—Ç—ã, –ª–∏–º–∏—Ç 3 —á–µ–ª–æ–≤–µ–∫–∞, –Ω–∏–∫–Ω–µ–π–º—ã –≤ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–∏
"""
import os
import asyncio
import logging
import sqlite3
import threading
import time
import requests
import re
from datetime import datetime, timezone, timedelta
from typing import Optional, Dict, List

# FastAPI
from fastapi import FastAPI
import uvicorn

# Telegram
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, BotCommand
from telegram.ext import (
    Application, 
    CommandHandler, 
    CallbackQueryHandler, 
    ContextTypes,
    MessageHandler,
    filters
)

# ================== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ==================
TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
if not TOKEN:
    raise ValueError("‚ùå –¢–æ–∫–µ–Ω –±–æ—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω! –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ TELEGRAM_BOT_TOKEN")

PORT = int(os.getenv("PORT", 10000))
DATABASE_URL = os.getenv("DATABASE_URL", "breaks.db")
RENDER_URL = "https://rs1-1.onrender.com"  # ‚úÖ –¢–≤–æ—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è –∞–≤—Ç–æ-–ø–∏–Ω–≥–∞

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

# FastAPI –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
app = FastAPI(
    title="Telegram Bot –¥–ª—è –∑–∞–ø–∏—Å–∏ –Ω–∞ –ø–µ—Ä–µ—Ä—ã–≤—ã",
    description="–ë–æ—Ç –¥–ª—è –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –ø–µ—Ä–µ—Ä—ã–≤–æ–≤ —Å 10-–º–∏–Ω—É—Ç–Ω—ã–º–∏ —Å–ª–æ—Ç–∞–º–∏",
    version="7.3"
)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
bot_app: Optional[Application] = None
startup_time = datetime.now(timezone.utc)

# ================== –ë–ê–ó–ê –î–ê–ù–ù–´–• ==================
def init_db():
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
    conn = sqlite3.connect(DATABASE_URL)
    cursor = conn.cursor()
    
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            first_name TEXT,
            last_name TEXT,
            registration_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS breaks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            break_time TEXT,
            break_date DATE,
            registration_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (user_id)
        )
    ''')
    
    conn.commit()
    conn.close()
    logger.info("‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")

# ================== –§–£–ù–ö–¶–ò–ò –î–õ–Ø 10-–ú–ò–ù–£–¢–ù–´–• –°–õ–û–¢–û–í ==================
def get_break_slots() -> List[str]:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ç–∞–π–º—Å–ª–æ—Ç–æ–≤ (10-–º–∏–Ω—É—Ç–Ω—ã–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã —Å 10:00 –¥–æ 18:50)"""
    slots = []
    for hour in range(10, 19):
        for minute in [0, 10, 20, 30, 40, 50]:
            if hour == 18 and minute > 50:
                continue
            start = f"{hour:02d}:{minute:02d}"
            end_minute = minute + 10
            end_hour = hour
            if end_minute >= 60:
                end_hour = hour + 1
                end_minute = end_minute - 60
            end = f"{end_hour:02d}:{end_minute:02d}"
            slots.append(f"{start}-{end}")
    return slots

def get_nearby_slots() -> List[str]:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ—Ç—ã –Ω–∞ –±–ª–∏–∂–∞–π—à–∏–µ 2 —á–∞—Å–∞ –æ—Ç —Ç–µ–∫—É—â–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ (10-–º–∏–Ω—É—Ç–Ω—ã–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã)"""
    moscow_tz = timezone(timedelta(hours=3))
    now = datetime.now(moscow_tz)
    current_hour = now.hour
    current_minute = now.minute
    
    # –û–∫—Ä—É–≥–ª—è–µ–º –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ 10-–º–∏–Ω—É—Ç–Ω–æ–≥–æ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞
    remainder = current_minute % 10
    if remainder == 0:
        start_minute = current_minute + 10
    else:
        start_minute = current_minute - remainder + 10
    
    start_hour = current_hour
    if start_minute >= 60:
        start_hour += 1
        start_minute -= 60
    
    nearby_slots = []
    all_slots = get_break_slots()
    
    # –ò—â–µ–º —Å–ª–æ—Ç—ã –Ω–∞ –±–ª–∏–∂–∞–π—à–∏–µ 2 —á–∞—Å–∞
    target_time = start_hour * 60 + start_minute
    max_time = target_time + 120
    
    for slot in all_slots:
        slot_start = slot.split('-')[0]
        slot_hour = int(slot_start.split(':')[0])
        slot_minute = int(slot_start.split(':')[1])
        slot_time = slot_hour * 60 + slot_minute
        
        if target_time <= slot_time <= max_time:
            nearby_slots.append(slot)
            if len(nearby_slots) >= 8:
                break
    
    return nearby_slots

def get_slot_status(slot: str, break_date: str) -> str:
    """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Å—Ç–∞—Ç—É—Å —Å–ª–æ—Ç–∞: —Å–≤–æ–±–æ–¥–Ω–æ, –º–∞–ª–æ –º–µ—Å—Ç, –∑–∞–Ω—è—Ç (–º–∞–∫—Å–∏–º—É–º 3 —á–µ–ª–æ–≤–µ–∫–∞)"""
    conn = sqlite3.connect(DATABASE_URL)
    cursor = conn.cursor()
    
    slot_start = slot.split('-')[0]
    
    cursor.execute('''
        SELECT COUNT(*) FROM breaks 
        WHERE break_time = ? AND break_date = ?
    ''', (slot_start, break_date))
    
    count = cursor.fetchone()[0]
    conn.close()
    
    if count >= 3:
        return "üî¥ –∑–∞–Ω—è—Ç"
    elif count >= 1:
        return "üü° –º–∞–ª–æ –º–µ—Å—Ç"
    else:
        return "üü¢ —Å–≤–æ–±–æ–¥–Ω–æ"

# ================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ==================
def get_moscow_time() -> str:
    """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –ø–æ –ú–æ—Å–∫–≤–µ"""
    moscow_tz = timezone(timedelta(hours=3))
    return datetime.now(moscow_tz).strftime("%H:%M")

def get_current_date() -> str:
    """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É"""
    return datetime.now(timezone(timedelta(hours=3))).strftime("%Y-%m-%d")

def save_user_to_db(user_id: int, username: str, first_name: str, last_name: str):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö"""
    conn = sqlite3.connect(DATABASE_URL)
    cursor = conn.cursor()
    
    cursor.execute('''
        INSERT OR IGNORE INTO users (user_id, username, first_name, last_name)
        VALUES (?, ?, ?, ?)
    ''', (user_id, username, first_name, last_name))
    
    conn.commit()
    conn.close()

def save_break_to_db(user_id: int, break_time: str, break_date: str) -> bool:
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –∑–∞–ø–∏—Å—å –Ω–∞ –ø–µ—Ä–µ—Ä—ã–≤ —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –ª–∏–º–∏—Ç–∞ –≤ 3 —á–µ–ª–æ–≤–µ–∫–∞"""
    conn = sqlite3.connect(DATABASE_URL)
    cursor = conn.cursor()
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–ø–∏—Å–∞–Ω –ª–∏ —É–∂–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    cursor.execute('''
        SELECT COUNT(*) FROM breaks 
        WHERE user_id = ? AND break_date = ? AND break_time = ?
    ''', (user_id, break_date, break_time))
    
    count = cursor.fetchone()[0]
    
    if count > 0:
        conn.close()
        return False
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø–∏—Å–µ–π –Ω–∞ —ç—Ç–æ—Ç —Å–ª–æ—Ç (–º–∞–∫—Å–∏–º—É–º 3)
    cursor.execute('''
        SELECT COUNT(*) FROM breaks 
        WHERE break_time = ? AND break_date = ?
    ''', (break_time, break_date))
    
    slot_count = cursor.fetchone()[0]
    
    if slot_count >= 3:
        conn.close()
        return False
    
    cursor.execute('''
        INSERT INTO breaks (user_id, break_time, break_date)
        VALUES (?, ?, ?)
    ''', (user_id, break_time, break_date))
    
    conn.commit()
    conn.close()
    return True

def delete_break_from_db(user_id: int, break_time: str, break_date: str) -> bool:
    """üóëÔ∏è –£–¥–∞–ª—è–µ—Ç –∑–∞–ø–∏—Å—å –Ω–∞ –ø–µ—Ä–µ—Ä—ã–≤ (–æ—Ç–º–µ–Ω–∞ –±—Ä–æ–Ω–∏)"""
    conn = sqlite3.connect(DATABASE_URL)
    cursor = conn.cursor()
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ç–∞–∫–∞—è –∑–∞–ø–∏—Å—å
    cursor.execute('''
        SELECT COUNT(*) FROM breaks 
        WHERE user_id = ? AND break_date = ? AND break_time = ?
    ''', (user_id, break_date, break_time))
    
    count = cursor.fetchone()[0]
    
    if count == 0:
        conn.close()
        return False
    
    # –£–¥–∞–ª—è–µ–º –∑–∞–ø–∏—Å—å
    cursor.execute('''
        DELETE FROM breaks 
        WHERE user_id = ? AND break_date = ? AND break_time = ?
    ''', (user_id, break_date, break_time))
    
    conn.commit()
    conn.close()
    return True

def get_user_breaks(user_id: int, break_date: str) -> List[str]:
    """–ü–æ–ª—É—á–∞–µ—Ç –ø–µ—Ä–µ—Ä—ã–≤—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    conn = sqlite3.connect(DATABASE_URL)
    cursor = conn.cursor()
    
    cursor.execute('''
        SELECT break_time FROM breaks 
        WHERE user_id = ? AND break_date = ?
        ORDER BY break_time
    ''', (user_id, break_date))
    
    breaks = [row[0] for row in cursor.fetchall()]
    conn.close()
    return breaks

def get_all_breaks(break_date: str) -> Dict[str, List[str]]:
    """–ü–æ–ª—É—á–∞–µ—Ç –≤—Å–µ –∑–∞–ø–∏—Å–∏ –Ω–∞ –ø–µ—Ä–µ—Ä—ã–≤—ã —Å –Ω–∏–∫–Ω–µ–π–º–∞–º–∏ (first_name)"""
    conn = sqlite3.connect(DATABASE_URL)
    cursor = conn.cursor()
    
    cursor.execute('''
        SELECT u.first_name, b.break_time 
        FROM breaks b
        JOIN users u ON b.user_id = u.user_id
        WHERE b.break_date = ?
        ORDER BY b.break_time
    ''', (break_date,))
    
    breaks = {}
    for first_name, break_time in cursor.fetchall():
        if break_time not in breaks:
            breaks[break_time] = []
        name = first_name if first_name else "–ê–Ω–æ–Ω–∏–º"
        breaks[break_time].append(name)
    
    conn.close()
    return breaks

def get_statistics() -> Dict:
    """–ü–æ–ª—É—á–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –∑–∞–ø–∏—Å—è–º"""
    conn = sqlite3.connect(DATABASE_URL)
    cursor = conn.cursor()
    
    cursor.execute("SELECT COUNT(*) FROM users")
    total_users = cursor.fetchone()[0]
    
    cursor.execute("SELECT COUNT(*) FROM breaks")
    total_breaks = cursor.fetchone()[0]
    
    current_date = get_current_date()
    cursor.execute("SELECT COUNT(*) FROM breaks WHERE break_date = ?", (current_date,))
    today_breaks = cursor.fetchone()[0]
    
    cursor.execute('''
        SELECT break_time, COUNT(*) as count 
        FROM breaks 
        GROUP BY break_time 
        ORDER BY count DESC 
        LIMIT 3
    ''')
    popular_times = cursor.fetchall()
    
    cursor.execute('''
        SELECT COUNT(DISTINCT user_id) 
        FROM breaks 
        WHERE break_date = ?
    ''', (current_date,))
    active_users = cursor.fetchone()[0]
    
    conn.close()
    
    return {
        "total_users": total_users,
        "total_breaks": total_breaks,
        "today_breaks": today_breaks,
        "popular_times": popular_times,
        "active_users": active_users
    }

# ================== –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô UX/UI ==================
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """üöÄ –ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ ‚Äî –ú–ò–ù–ò–ú–ê–õ–ò–ó–ú"""
    user = update.effective_user
    chat_id = update.effective_chat.id
    
    logger.info(f"üöÄ /start –æ—Ç {user.id}")
    
    save_user_to_db(
        user_id=user.id,
        username=user.username,
        first_name=user.first_name,
        last_name=user.last_name
    )
    
    welcome_text = (
        f"üëã {user.first_name}, –∑–∞–ø–∏—Å—ã–≤–∞–π—Å—è –Ω–∞ –ø–µ—Ä–µ—Ä—ã–≤!\n\n"
        f"‚è±Ô∏è 10 –º–∏–Ω ¬∑ üë• –¥–æ 3 —á–µ–ª.\n"
        f"üìÖ {get_current_date()} ¬∑ ‚è∞ {get_moscow_time()}\n"
    )
    
    keyboard = [
        [InlineKeyboardButton("üìÖ –ó–∞–ø–∏—Å–∞—Ç—å—Å—è", callback_data="show_breaks")],
        [
            InlineKeyboardButton("üìã –ú–æ–∏", callback_data="my_breaks"),
            InlineKeyboardButton("üë• –í—Å–µ", callback_data="today_schedule")
        ],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await context.bot.send_message(
        chat_id=chat_id,
        text=welcome_text,
        reply_markup=reply_markup
    )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /help"""
    help_text = (
        "ü§ñ –ü–æ–º–æ—â—å –ø–æ –±–æ—Ç—É\n\n"
        "–ö–æ–º–∞–Ω–¥—ã:\n"
        "/start - –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n"
        "/breaks - –ó–∞–ø–∏—Å–∞—Ç—å—Å—è\n"
        "/my_breaks - –ú–æ–∏ –∑–∞–ø–∏—Å–∏\n"
        "/today - –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ\n"
        "/stats - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n\n"
        "‚è±Ô∏è –°–ª–æ—Ç—ã: 10 –º–∏–Ω\n"
        "üë• –õ–∏–º–∏—Ç: 3 —á–µ–ª.\n"
        "üóëÔ∏è –û—Ç–º–µ–Ω–∞: –≤ —Ä–∞–∑–¥–µ–ª–µ '–ú–æ–∏ –∑–∞–ø–∏—Å–∏'\n"
    )
    
    await update.message.reply_text(help_text)

async def breaks_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /breaks"""
    await show_breaks_menu(update, context)

async def my_breaks_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /my_breaks"""
    await show_my_breaks(update, context)

async def today_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /today"""
    await show_today_schedule(update, context)

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /stats"""
    await show_statistics(update, context)

async def debug_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /debug - –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–±–æ—Ç—ã"""
    user = update.effective_user
    
    logger.info(f"üîç /debug –æ—Ç {user.id}")
    
    db_status = "‚úÖ –†–∞–±–æ—Ç–∞–µ—Ç"
    try:
        conn = sqlite3.connect(DATABASE_URL)
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM users")
        user_count = cursor.fetchone()[0]
        cursor.execute("SELECT COUNT(*) FROM breaks")
        break_count = cursor.fetchone()[0]
        conn.close()
        db_info = f"üë• {user_count} ¬∑ üìù {break_count}"
    except Exception as e:
        db_status = f"‚ùå –û—à–∏–±–∫–∞"
        db_info = str(e)[:100]
    
    response = (
        f"üîß –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞\n\n"
        f"ü§ñ –ë–æ—Ç: ‚úÖ\n"
        f"üïê {get_moscow_time()} ¬∑ üìÖ {get_current_date()}\n"
        f"üóÑÔ∏è –ë–î: {db_status}\n"
        f"   {db_info}\n"
        f"‚è±Ô∏è 10 –º–∏–Ω ¬∑ üë• 3 —á–µ–ª. ¬∑ üóëÔ∏è –û—Ç–º–µ–Ω–∞ –µ—Å—Ç—å\n"
        f"üåê {RENDER_URL}"
    )
    
    await update.message.reply_text(response)

# ================== –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò INLINE-–ö–ù–û–ü–û–ö ==================
async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏–π –Ω–∞ inline-–∫–Ω–æ–ø–∫–∏"""
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    data = query.data
    
    logger.info(f"üîò –ö–Ω–æ–ø–∫–∞: {data} –æ—Ç {user_id}")
    
    if data == "show_breaks":
        await show_breaks_menu(update, context)
    elif data == "my_breaks":
        await show_my_breaks(update, context)
    elif data == "today_schedule":
        await show_today_schedule(update, context)
    elif data == "show_stats":
        await show_statistics(update, context)
    elif data.startswith("select_"):
        break_time = data.replace("select_", "")
        await confirm_break_selection(update, context, break_time)
    elif data.startswith("confirm_cancel_"):  # üü¢ –û–¢–ú–ï–ù–ê - –ü–ï–†–í–ê–Ø! (–≤–∞–∂–µ–Ω –ø–æ—Ä—è–¥–æ–∫)
        break_time = data.replace("confirm_cancel_", "")
        await process_break_cancellation(update, context, break_time)
    elif data.startswith("confirm_"):         # üü¢ –ó–ê–ü–ò–°–¨ - –í–¢–û–†–ê–Ø!
        break_time = data.replace("confirm_", "")
        await process_break_registration(update, context, break_time)
    elif data.startswith("cancel_"):
        break_time = data.replace("cancel_", "")
        await confirm_cancel_break(update, context, break_time)
    elif data == "back_to_menu":
        await start_command(update, context)

async def show_breaks_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """‚è≥ –í–´–ë–û–† –í–†–ï–ú–ï–ù–ò ‚Äî –ß–ò–°–¢–´–ô –ò–ù–¢–ï–†–§–ï–ô–°"""
    query = update.callback_query
    user_id = query.from_user.id if query else update.effective_user.id
    
    current_date = get_current_date()
    user_breaks = get_user_breaks(user_id, current_date)
    nearby_slots = get_nearby_slots()
    
    keyboard = []
    
    for slot in nearby_slots:
        slot_start = slot.split('-')[0]
        status = get_slot_status(slot, current_date)
        
        if slot_start in user_breaks:
            icon = "‚úÖ"
        elif "üî¥" in status:
            icon = "üî¥"
        elif "üü°" in status:
            icon = "üü°"
        else:
            icon = "üü¢"
        
        button_text = f"{icon} {slot}"
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"select_{slot_start}")])
    
    keyboard.append([InlineKeyboardButton("‚Üê –ù–∞–∑–∞–¥", callback_data="back_to_menu")])
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    text = (
        f"‚è≥ –ë–ª–∏–∂–∞–π—à–∏–µ 2 —á–∞—Å–∞\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"üü¢ —Å–≤–æ–±–æ–¥–Ω–æ ¬∑ üü° 1-2 —á–µ–ª ¬∑ üî¥ –∑–∞–Ω—è—Ç–æ\n"
        f"‚úÖ –≤—ã –∑–∞–ø–∏—Å–∞–Ω—ã\n"
    )
    
    if query:
        await query.edit_message_text(text=text, reply_markup=reply_markup)
    else:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=text,
            reply_markup=reply_markup
        )

async def confirm_break_selection(update: Update, context: ContextTypes.DEFAULT_TYPE, break_time: str):
    """‚úÖ –ü–û–î–¢–í–ï–†–ñ–î–ï–ù–ò–ï –ó–ê–ü–ò–°–ò"""
    query = update.callback_query
    
    full_slot = break_time
    for slot in get_break_slots():
        if slot.startswith(break_time):
            full_slot = slot
            break
    
    text = f"‚úÖ {full_slot}\n\n–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –∑–∞–ø–∏—Å—å?"
    
    keyboard = [
        [
            InlineKeyboardButton("‚úÖ –î–∞", callback_data=f"confirm_{break_time}"),
            InlineKeyboardButton("‚ùå –ù–µ—Ç", callback_data="show_breaks")
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(text=text, reply_markup=reply_markup)

async def process_break_registration(update: Update, context: ContextTypes.DEFAULT_TYPE, break_time: str):
    """üéâ –ó–ê–ü–ò–°–¨ –ù–ê –ü–ï–†–ï–†–´–í"""
    query = update.callback_query
    user_id = query.from_user.id
    current_date = get_current_date()
    
    success = save_break_to_db(user_id, break_time, current_date)
    
    full_slot = break_time
    for slot in get_break_slots():
        if slot.startswith(break_time):
            full_slot = slot
            break
    
    if success:
        conn = sqlite3.connect(DATABASE_URL)
        cursor = conn.cursor()
        cursor.execute('''
            SELECT COUNT(*) FROM breaks 
            WHERE break_time = ? AND break_date = ?
        ''', (break_time, current_date))
        current_count = cursor.fetchone()[0]
        conn.close()
        
        text = (
            f"‚úÖ –¢—ã –∑–∞–ø–∏—Å–∞–Ω –Ω–∞ {full_slot}!\n"
            f"üë• –ú–µ—Å—Ç: {current_count}/3\n\n"
            f"üóëÔ∏è –û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–ø–∏—Å—å –º–æ–∂–Ω–æ –≤ —Ä–∞–∑–¥–µ–ª–µ ¬´–ú–æ–∏¬ª"
        )
        logger.info(f"‚úÖ –ó–∞–ø–∏—Å—å: {user_id} –Ω–∞ {break_time} ({current_count}/3)")
    else:
        conn = sqlite3.connect(DATABASE_URL)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT COUNT(*) FROM breaks 
            WHERE user_id = ? AND break_date = ? AND break_time = ?
        ''', (user_id, current_date, break_time))
        already_registered = cursor.fetchone()[0] > 0
        
        cursor.execute('''
            SELECT COUNT(*) FROM breaks 
            WHERE break_time = ? AND break_date = ?
        ''', (break_time, current_date))
        slot_full = cursor.fetchone()[0] >= 3
        
        conn.close()
        
        if already_registered:
            text = f"‚ö†Ô∏è –¢—ã —É–∂–µ –∑–∞–ø–∏—Å–∞–Ω –Ω–∞ {full_slot}"
        elif slot_full:
            text = f"üî¥ –°–ª–æ—Ç {full_slot} –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–Ω—è—Ç"
        else:
            text = "‚ùå –û—à–∏–±–∫–∞, –ø–æ–ø—Ä–æ–±—É–π –µ—â–µ"
        
        logger.info(f"‚ö†Ô∏è –ó–∞–ø–∏—Å—å –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞: {user_id} –Ω–∞ {break_time}")
    
    keyboard = [
        [InlineKeyboardButton("üìÖ –ï—â–µ –∑–∞–ø–∏—Å—å", callback_data="show_breaks")],
        [InlineKeyboardButton("üìã –ú–æ–∏ –∑–∞–ø–∏—Å–∏", callback_data="my_breaks")],
        [InlineKeyboardButton("‚Üê –í –º–µ–Ω—é", callback_data="back_to_menu")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(text=text, reply_markup=reply_markup)

async def show_my_breaks(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """üìã –ú–û–ò –ó–ê–ü–ò–°–ò ‚Äî –° –ö–ù–û–ü–ö–û–ô –û–¢–ú–ï–ù–´"""
    query = update.callback_query
    user_id = query.from_user.id if query else update.effective_user.id
    current_date = get_current_date()
    
    user_breaks = get_user_breaks(user_id, current_date)
    
    text = f"üìã –ú–æ–∏ –∑–∞–ø–∏—Å–∏ ¬∑ {current_date}\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
    keyboard = []
    
    if user_breaks:
        for break_time in user_breaks:
            full_slot = break_time
            for slot in get_break_slots():
                if slot.startswith(break_time):
                    full_slot = slot
                    break
            
            text += f"‚úÖ {full_slot}\n"
            
            # üóëÔ∏è –ö–Ω–æ–ø–∫–∞ –æ—Ç–º–µ–Ω—ã –¥–ª—è –∫–∞–∂–¥–æ–π –∑–∞–ø–∏—Å–∏
            keyboard.append([InlineKeyboardButton(
                f"‚ùå –û—Ç–º–µ–Ω–∏—Ç—å {full_slot}", 
                callback_data=f"cancel_{break_time}"
            )])
    else:
        text += "üò¥ –ù–µ—Ç –∑–∞–ø–∏—Å–µ–π"
    
    keyboard.append([InlineKeyboardButton("üìÖ –ó–∞–ø–∏—Å–∞—Ç—å—Å—è", callback_data="show_breaks")])
    keyboard.append([InlineKeyboardButton("‚Üê –ù–∞–∑–∞–¥", callback_data="back_to_menu")])
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if query:
        await query.edit_message_text(text=text, reply_markup=reply_markup)
    else:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=text,
            reply_markup=reply_markup
        )

async def confirm_cancel_break(update: Update, context: ContextTypes.DEFAULT_TYPE, break_time: str):
    """‚ùì –ü–û–î–¢–í–ï–†–ñ–î–ï–ù–ò–ï –û–¢–ú–ï–ù–´"""
    query = update.callback_query
    
    full_slot = break_time
    for slot in get_break_slots():
        if slot.startswith(break_time):
            full_slot = slot
            break
    
    text = f"‚ùå {full_slot}\n\n–û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–ø–∏—Å—å?"
    
    keyboard = [
        [
            InlineKeyboardButton("‚úÖ –î–∞, –æ—Ç–º–µ–Ω–∏—Ç—å", callback_data=f"confirm_cancel_{break_time}"),
            InlineKeyboardButton("‚ùå –ù–µ—Ç", callback_data="my_breaks")
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(text=text, reply_markup=reply_markup)

async def process_break_cancellation(update: Update, context: ContextTypes.DEFAULT_TYPE, break_time: str):
    """üóëÔ∏è –û–ë–†–ê–ë–û–¢–ö–ê –û–¢–ú–ï–ù–´ –ó–ê–ü–ò–°–ò (–£–î–ê–õ–ï–ù–ò–ï –ò–ó –ë–î)"""
    query = update.callback_query
    user_id = query.from_user.id
    current_date = get_current_date()
    
    # ‚úÖ –£–î–ê–õ–Ø–ï–ú –∑–∞–ø–∏—Å—å, –∞ –Ω–µ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é
    success = delete_break_from_db(user_id, break_time, current_date)
    
    full_slot = break_time
    for slot in get_break_slots():
        if slot.startswith(break_time):
            full_slot = slot
            break
    
    if success:
        text = f"‚úÖ –ó–∞–ø–∏—Å—å –Ω–∞ {full_slot} –æ—Ç–º–µ–Ω–µ–Ω–∞!\n\n–°–ª–æ—Ç —Å–Ω–æ–≤–∞ —Å–≤–æ–±–æ–¥–µ–Ω üü¢"
        logger.info(f"üóëÔ∏è –û—Ç–º–µ–Ω–∞ –∑–∞–ø–∏—Å–∏: {user_id} —Å–Ω—è–ª {break_time}")
    else:
        text = "‚ùå –ó–∞–ø–∏—Å—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —É–∂–µ –æ—Ç–º–µ–Ω–µ–Ω–∞"
        logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ç–º–µ–Ω—ã: {user_id} ‚Äî –∑–∞–ø–∏—Å—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
    
    keyboard = [
        [InlineKeyboardButton("üìã –ú–æ–∏ –∑–∞–ø–∏—Å–∏", callback_data="my_breaks")],
        [InlineKeyboardButton("‚Üê –í –º–µ–Ω—é", callback_data="back_to_menu")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(text=text, reply_markup=reply_markup)

async def show_today_schedule(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """üë• –†–ê–°–ü–ò–°–ê–ù–ò–ï ‚Äî –¢–û–õ–¨–ö–û –ó–ê–ù–Ø–¢–´–ï –°–õ–û–¢–´"""
    query = update.callback_query
    current_date = get_current_date()
    
    all_breaks = get_all_breaks(current_date)
    
    text = f"üë• –ó–∞–Ω—è—Ç—ã–µ —Å–ª–æ—Ç—ã ¬∑ {current_date}\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
    
    if not all_breaks:
        text += "üò¥ –ü–æ–∫–∞ –Ω–∏–∫—Ç–æ –Ω–µ –∑–∞–ø–∏—Å–∞–Ω\n"
    else:
        for break_time, names in sorted(all_breaks.items()):
            full_slot = break_time
            for slot in get_break_slots():
                if slot.startswith(break_time):
                    full_slot = slot
                    break
            text += f"‚Ä¢ {full_slot} ‚Äî {', '.join(names)}\n"
    
    total_booked = len(all_breaks)
    text += f"\nüìä –ó–∞–Ω—è—Ç–æ: {total_booked} —Å–ª–æ—Ç–æ–≤"
    
    keyboard = [
        [InlineKeyboardButton("üìÖ –ó–∞–ø–∏—Å–∞—Ç—å—Å—è", callback_data="show_breaks")],
        [InlineKeyboardButton("‚Üê –ù–∞–∑–∞–¥", callback_data="back_to_menu")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if query:
        await query.edit_message_text(text=text, reply_markup=reply_markup)
    else:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=text,
            reply_markup=reply_markup
        )

async def show_statistics(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê ‚Äî –ö–û–ú–ü–ê–ö–¢–ù–û"""
    query = update.callback_query
    
    stats = get_statistics()
    current_date = get_current_date()
    all_breaks = get_all_breaks(current_date)
    booked_slots = len(all_breaks)
    
    text = (
        f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        f"üë• –í—Å–µ–≥–æ: {stats['total_users']}\n"
        f"üìù –ó–∞–ø–∏—Å–µ–π: {stats['total_breaks']}\n\n"
        f"üìÖ –°–µ–≥–æ–¥–Ω—è:\n"
        f"‚Ä¢ –ó–∞–ø–∏—Å–µ–π: {stats['today_breaks']}\n"
        f"‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö: {stats['active_users']}\n"
        f"‚Ä¢ –ó–∞–Ω—è—Ç–æ: {booked_slots} —Å–ª–æ—Ç–æ–≤\n"
    )
    
    if stats['popular_times']:
        text += f"\nüî• –ü–æ–ø—É–ª—è—Ä–Ω–æ–µ:\n"
        for i, (time, count) in enumerate(stats['popular_times'], 1):
            for slot in get_break_slots():
                if slot.startswith(time):
                    text += f"‚Ä¢ {slot} ‚Äî {count} –∑–∞–ø.\n"
                    break
    
    keyboard = [
        [InlineKeyboardButton("üìÖ –ó–∞–ø–∏—Å–∞—Ç—å—Å—è", callback_data="show_breaks")],
        [InlineKeyboardButton("‚Üê –ù–∞–∑–∞–¥", callback_data="back_to_menu")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if query:
        await query.edit_message_text(text=text, reply_markup=reply_markup)
    else:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=text,
            reply_markup=reply_markup
        )

# ================== –ó–ê–ü–£–°–ö –¢–ï–õ–ï–ì–†–ê–ú –ë–û–¢–ê ==================
async def setup_bot_commands(application: Application):
    """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫–æ–º–∞–Ω–¥ –¥–ª—è –º–µ–Ω—é Telegram"""
    commands = [
        BotCommand("start", "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"),
        BotCommand("breaks", "üìù –ó–∞–ø–∏—Å–∞—Ç—å—Å—è"),
        BotCommand("my_breaks", "üìã –ú–æ–∏ –∑–∞–ø–∏—Å–∏"),
        BotCommand("today", "üë• –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ"),
        BotCommand("stats", "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"),
        BotCommand("help", "‚ùì –ü–æ–º–æ—â—å"),
        BotCommand("debug", "üîß –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞"),
    ]
    await application.bot.set_my_commands(commands)
    logger.info("‚úÖ –ö–æ–º–∞–Ω–¥—ã –º–µ–Ω—é —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã")

async def start_bot():
    """–ó–∞–ø—É—Å–∫ Telegram –±–æ—Ç–∞"""
    global bot_app
    
    logger.info("ü§ñ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram –±–æ—Ç–∞...")
    
    await asyncio.sleep(5)
    
    try:
        bot_app = Application.builder().token(TOKEN).build()
        logger.info("‚úÖ –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–æ")
        
        await setup_bot_commands(bot_app)
        
        bot_app.add_handler(CommandHandler("start", start_command))
        bot_app.add_handler(CommandHandler("help", help_command))
        bot_app.add_handler(CommandHandler("debug", debug_command))
        bot_app.add_handler(CommandHandler("breaks", breaks_command))
        bot_app.add_handler(CommandHandler("my_breaks", my_breaks_command))
        bot_app.add_handler(CommandHandler("today", today_command))
        bot_app.add_handler(CommandHandler("stats", stats_command))
        
        bot_app.add_handler(CallbackQueryHandler(button_callback))
        
        logger.info("‚úÖ –í—Å–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–æ–±–∞–≤–ª–µ–Ω—ã")
        
        await bot_app.initialize()
        await bot_app.start()
        
        await bot_app.updater.start_polling(
            poll_interval=1.0,
            timeout=20,
            drop_pending_updates=True
        )
        
        logger.info("‚úÖ Telegram –±–æ—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω!")
        return True
        
    except Exception as e:
        logger.error(f"üí• –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞: {e}")
        return False

# ================== –ê–í–¢–û-–ü–ò–ù–ì ==================
def start_auto_ping():
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç –∞–≤—Ç–æ-–ø–∏–Ω–≥ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ"""
    def ping_worker():
        time.sleep(30)
        logger.info(f"üßµ –ê–≤—Ç–æ-–ø–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω –¥–ª—è {RENDER_URL}")
        
        ping_count = 0
        while True:
            ping_count += 1
            try:
                response = requests.get(f"{RENDER_URL}/health", timeout=10)
                if response.status_code == 200:
                    logger.info(f"‚úÖ –ê–≤—Ç–æ-–ø–∏–Ω–≥ #{ping_count} —É—Å–ø–µ—à–µ–Ω")
                else:
                    logger.warning(f"‚ö†Ô∏è –ê–≤—Ç–æ-–ø–∏–Ω–≥ #{ping_count}: –∫–æ–¥ {response.status_code}")
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∞–≤—Ç–æ-–ø–∏–Ω–≥–∞ #{ping_count}: {e}")
            
            time.sleep(480)  # 8 –º–∏–Ω—É—Ç
    
    thread = threading.Thread(target=ping_worker, daemon=True)
    thread.start()
    logger.info("‚úÖ –ü–æ—Ç–æ–∫ –∞–≤—Ç–æ-–ø–∏–Ω–≥–∞ —Å–æ–∑–¥–∞–Ω")
    return thread

# ================== FASTAPI –≠–ù–î–ü–û–ò–ù–¢–´ ==================
@app.get("/")
async def root():
    """–ö–æ—Ä–Ω–µ–≤–æ–π —ç–Ω–¥–ø–æ–∏–Ω—Ç"""
    return {
        "message": "Telegram Bot –¥–ª—è –∑–∞–ø–∏—Å–∏ –Ω–∞ –ø–µ—Ä–µ—Ä—ã–≤—ã",
        "status": "running",
        "bot": "active" if bot_app else "starting",
        "time_moscow": get_moscow_time(),
        "date": get_current_date(),
        "uptime": str(datetime.now(timezone.utc) - startup_time),
        "version": "7.3",
        "render_url": RENDER_URL,
        "slot_duration": "10 –º–∏–Ω—É—Ç",
        "slot_limit": "3 —á–µ–ª–æ–≤–µ–∫–∞",
        "cancellation": "–¥–æ—Å—Ç—É–ø–Ω–∞"
    }

@app.get("/health")
async def health_check():
    """Health check –¥–ª—è Render"""
    return {
        "status": "healthy",
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "bot_running": bool(bot_app),
        "time_moscow": get_moscow_time(),
        "render_url": RENDER_URL
    }

@app.get("/status")
async def status():
    """–°—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º—ã"""
    return {
        "server": {
            "uptime": str(datetime.now(timezone.utc) - startup_time),
            "port": PORT,
            "startup_time": startup_time.isoformat(),
            "render_url": RENDER_URL
        },
        "bot": {
            "initialized": bool(bot_app),
            "database": "connected",
            "menu_type": "inline_buttons_optimized",
            "slot_duration": "10 –º–∏–Ω—É—Ç",
            "slot_limit": "3 —á–µ–ª–æ–≤–µ–∫–∞",
            "cancellation": "–¥–æ—Å—Ç—É–ø–Ω–∞"
        }
    }

@app.get("/ping")
async def ping():
    """–†—É—á–Ω–æ–π –ø–∏–Ω–≥"""
    return {"ping": "pong", "time": get_moscow_time(), "render_url": RENDER_URL}

# ================== –ó–ê–ü–£–°–ö –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø ==================
@app.on_event("startup")
async def startup_event():
    """–ó–∞–ø—É—Å–∫ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
    logger.info("=" * 60)
    logger.info("üöÄ –ó–ê–ü–£–°–ö –ë–û–¢–ê –î–õ–Ø –ó–ê–ü–ò–°–ò –ù–ê –ü–ï–†–ï–†–´–í–´ (–° –û–¢–ú–ï–ù–û–ô –ó–ê–ü–ò–°–ò)")
    logger.info("=" * 60)
    
    init_db()
    
    logger.info(f"‚úÖ –¢–æ–∫–µ–Ω –±–æ—Ç–∞: –ù–∞–π–¥–µ–Ω")
    logger.info(f"‚è∞ –í—Ä–µ–º—è –ø–æ –ú–æ—Å–∫–≤–µ: {get_moscow_time()}")
    logger.info(f"üìÖ –î–∞—Ç–∞: {get_current_date()}")
    logger.info(f"üåê –ü–æ—Ä—Ç: {PORT}")
    logger.info(f"üåç Render URL: {RENDER_URL}")
    logger.info(f"‚è±Ô∏è –¢–∞–π–º—Å–ª–æ—Ç—ã: 10 –º–∏–Ω—É—Ç")
    logger.info(f"üë• –õ–∏–º–∏—Ç: 3 —á–µ–ª–æ–≤–µ–∫–∞ –Ω–∞ —Å–ª–æ—Ç")
    logger.info(f"üóëÔ∏è –û—Ç–º–µ–Ω–∞ –∑–∞–ø–∏—Å–∏: –î–û–°–¢–£–ü–ù–ê")
    logger.info("=" * 60)
    
    start_auto_ping()
    logger.info("üîß –ê–≤—Ç–æ-–ø–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω (–ø–∏–Ω–≥ –∫–∞–∂–¥—ã–µ 8 –º–∏–Ω—É—Ç)")
    
    success = await start_bot()
    
    if success:
        logger.info("üéâ –í—Å–µ —Å–∏—Å—Ç–µ–º—ã –∑–∞–ø—É—â–µ–Ω—ã –∏ –≥–æ—Ç–æ–≤—ã –∫ —Ä–∞–±–æ—Ç–µ!")
        logger.info("üé® –†–µ–∂–∏–º: INLINE –ö–ù–û–ü–ö–ò | –û–¢–ú–ï–ù–ê –ó–ê–ü–ò–°–ò | UX/UI –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù")
        logger.info(f"üåç –ü–∏–Ω–≥ –Ω–∞: {RENDER_URL}")
    else:
        logger.error("üí• –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞!")

@app.on_event("shutdown")
async def shutdown_event():
    """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏"""
    logger.info("üõë –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã...")
    
    if bot_app:
        try:
            await bot_app.updater.stop()
            await bot_app.stop()
            await bot_app.shutdown()
            logger.info("‚úÖ Telegram –±–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ –±–æ—Ç–∞: {e}")
    
    logger.info("üëã –°–µ—Ä–≤–µ—Ä –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

# ================== –¢–û–ß–ö–ê –í–•–û–î–ê ==================
def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞"""
    logger.info(f"üåç –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞ –Ω–∞ –ø–æ—Ä—Ç—É {PORT}...")
    
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=PORT,
        access_log=False,
        log_level="info"
    )

if __name__ == "__main__":
    main()
